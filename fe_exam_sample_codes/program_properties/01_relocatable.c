#include <stdio.h>
// 再配置可能プログラムの考え方を理解する
// 定義：主記憶上のどこに配置されても実行することができる性質
// 実現方法：アドレスを相対指定することで、配置位置が変わっても正しく実行できる。

int main(void)
{
    int data[5] = {10, 20, 30, 40, 50}; // データを連続したメモリに保存する考え方
    int *p = data;                      // ポインタ変数pにdataの先頭アドレスを代入

    // printf("アドレス値： %p\n", p);  // 先頭アドレスを確認
    // printf("格納データ： %d\n", *p); // 先頭アドレスのデータ内容を確認

    for (int i = 0; i < 5; i++)
    {
        printf("アドレス値： %p\n", p + i);  // i番目アドレスを確認
        printf("格納データ： %d\n", *(p + i)); // i番目のアドレスのデータ内容を確認
    }

    return 0;
}

//実行によって得られた結果
// 【1回目】
// アドレス値： 0x16bbe6e60
// 格納データ： 10
// アドレス値： 0x16bbe6e64
// 格納データ： 20
// アドレス値： 0x16bbe6e68
// 格納データ： 30
// アドレス値： 0x16bbe6e6c
// 格納データ： 40
// アドレス値： 0x16bbe6e70
// 格納データ： 50
// 【2回目】
// アドレス値： 0x16ef5ae60
// 格納データ： 10
// アドレス値： 0x16ef5ae64
// 格納データ： 20
// アドレス値： 0x16ef5ae68
// 格納データ： 30
// アドレス値： 0x16ef5ae6c
// 格納データ： 40
// アドレス値： 0x16ef5ae70
// 格納データ： 50

//プログラムをロードしたとき、変数の先頭アドレスには、違うアドレスが割り振られている(0x16bbe6e60)、(0x16ef5ae60)
//これにより、ロード時に毎回同じアドレスに割り当てられる保証はないことが確認できた。
//ロードされたアドレスに対して相対的な位置(p + i)でアクセスしているので、
//先頭アドレスがどこに行ったとしても正しくデータを取り出すことができた。